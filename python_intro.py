# -*- coding: utf-8 -*-
"""[Python]_Intro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11CaD3esN_7TGMOaBjsWN0UsGNTVT-uw9

# Arithmetic

- +
- -
- *
- /
- //
- %
- **
"""

print(type(6))
print(type(2-4))
print(type(4*4))
print(type(2/4))

print(7//4)

print(7%4)

print(2**10)

print(1 + 3*2)

"""# Variables

Best Practises around Variables

- snake case
- lower case / underscore
- letters, numbers, underscore
- case sensitive

Type of variables:

- int
- float
- str
- list
- tuple
- dict
- set
- bool

Int, Float
"""

# Declaration and Initialization
x = 5
# y = "Hello"
print(x)

# Constants vs Variables

PI = 3.14
weather_bucuresti = 20

# Different Data Types
num = 10            # Integer
price = 20.5        # Float
text = "Python"    # String
is_active = True   # Boolean

# OBS: Expression vs Statements
salariu = 100 #statement
chirie = salariu / 5 #statement / expression

"""# Strings

Strings
"""

cea_mai_top_banca = 'ING'
cea_mai_top_companie = 'Hubs'

query = '''
SELECT o coloana
FROM baza_aia_de_date
GROUPBY ceva
'''

query

# String concatenation
unde_lucram = cea_mai_top_banca + ' ' + cea_mai_top_companie
anul = 2023 print(unde_lucram)

# f string + string concat rules
print("Eu lucrez in" + unde_lucram + ' ' + "in anul" +  ' ' + str(2023))

print(f"Eu lucrez in {unde_lucram} in {anul} ")

# String Indexes
compania_noastra = "ING HUBS"
                   #01234567


[start::step]

# print(compania_noastra[0:3])

# print(compania_noastra[:2])
# print(compania_noastra[2:])
# print(compania_noastra[0:6:2])
# print(compania_noastra[::2])
# print(compania_noastra[-1])
print(compania_noastra[::-1])

"""# Booleans"""

invat_python = True
pare_complicat = False

"""# List

List - ordered sequence of objects (any type)
"""

# first data structure u learn :)

list = [1,23,5,65,23]
list_2 = ['a', 'd', 'd']
list_3 = [1, 2, 'add', True]

user_id = [122, 187, 2002]

# print(user_id[2])
# print(user_id[3])

"""### Va roaga baiatu sa cititi aici  

- https://www.w3schools.com/python/python_ref_list.asp
- https://www.w3schools.com/python/python_ref_keywords.asp

Slicing list
"""

bank_products = ['loan', 'investments', 'mortgages', 'insurances']
bank_products

# print(bank_products[0:3])
# print(bank_products[1::2])

# Immutability

## String

# company_name = 'ING_HUBS'
# # company_name[0]

# company_name[0] = 'Y'


## List
bank_products = ['loan', 'investments', 'mortgages', 'insurances']
bank_products[3] = 'health_insurance'

bank_products

"""# Matrix

Matrix - multi dimensional list
"""

matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]
          ]

# print(matrix[1][2])
# print(matrix[2][0:2])
# print(matrix[0][-1])
print(matrix[0][::-1])

"""# Dictionaries"""

dict = {
    'key1' : [1,2,3],
    'key2' : True,
    'key3' : 'chec',
    'key4' : 2.3,
}

# print(dict['key1'])
# print(dict[2])
# print(dict['key1'][1:3])
# print(dict['key4'][0])

# OBS: Mare mindblown

my_list = [{
    'key1' : [1,2,3],
    'key2' : True,
    'key3' : 'chec',
    'key4' : 2.3,
},
           {
    'key1' : [1,2,3],
    'key2' : True,
    'key3' : 'chec',
    'key4' : 2.3,
}]

print(my_list)

# print(dict.keys())
print(dict.items())

"""# Tuple"""

my_tuple = (1,2,3,4,5)

my_tuple[1] = 'z'

print(my_tuple[1])

print(my_tuple[1:2])

# Tuple methods

my_tuple.count(5)

my_tuple.index(5)



"""# Va roaga baiatu sa cititi despre set aici

https://www.freecodecamp.org/news/python-set-how-to-create-sets-in-python/
"""





"""# If statements"""

e_miercuri = True
stef_propune_mancare = False

foame_mare = True
am_chef_de_reper = False

e_miercuri = False
stef_propune_mancare = False
am_hungry = False

if e_miercuri and stef_propune_mancare:
    print("Mancam ceva bun")
elif not stef_propune_mancare:
    if am_hungry:
        print("Ayaye, ma duc jos la reper sa mananc, pana mea nu imi place, dar lesin de foame")
    else:
        print("Bag picioru fac fasting, decat sa mananc la reper")
else:
    print("Sunt de acasa cozy si fac ce vreau eu")

"""# For loops"""

numbers = [1,2,3,4,5,6]

for num in numbers:
  print(num)

text = "Imi place sa mananc doar la REPER"

for index,char in enumerate(text):
  if index % 2 == 0:
    print(char)

for i in range(5):
  print(i)

matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]]

# todo

for i in range(3):
  for j in range(3):
    if i == j:
      print(matrix[i][j])



"""# For loops extras"""

# enumerate

for i, char in enumerate('Grupul vesel de python'):
  print(i, char)

for i, num in enumerate(list(range(100))):
  if num == 50:
    print(f'index of 50 is :{i}')

# while

my_list=[1,2,3]

for item in my_list:
  print(item)

i = 0
while i < len(my_list):
  print(my_list[i])
  i += 1

"""break vs continue vs pass"""

for i in range(5):
  if i == 3:
    break
  print(i)

for i in range(5):
  if i == 3:
    continue
  print(i)

for i in range(5):
  if i == 3:
    pass
  print(i)

"""# Your time"""

poza = [
    [0,0,0,1,0,0,0],
    [0,0,1,1,1,0,0],
    [0,1,1,1,1,1,0],
    [1,1,1,1,1,1,1],
    [0,0,0,1,0,0,0]
]

for row in poza:
  print("Row: ", row)
  for pixel in row:
    if pixel:
      print('*', end='')
    else:
      print(' ', end ='')
  print('')

print('\n'.join(''.join('*' if el else ' ' for el in row) for row in poza))

my_list = ['a', 'b', 'c', 'd', 'd', 'e', 'f']

counts = {}
for item in my_list:
  print("Item: ", item)
  if item in counts:
      counts[item] += 1
      print("counts: ", counts.keys(), counts.values())
  else:
      counts[item] = 1

for item, count in counts.items():
    if count > 1:
        print(item)

"""# Functions"""

def say_hello():
  print("Hello!")

say_hello()

def say_hello_fancy(name, emoji):
  print(f'Hello {name} {emoji}')

say_hello_fancy('Daniel', 'ðŸ˜„')

say_hello_fancy('ðŸ˜„', 'Daniel')

say_hello_fancy(name = 'Daniel',
                emoji = 'ðŸ˜„')

say_hello_fancy()

def say_hello_fancy_default(name = 'INGHubs', emoji = 'ðŸ’»'):
  print(f'Hello {name} {emoji}')

say_hello_fancy_default('Daniel')

"""# Methods vs Functions"""

# Methods

list()
print()
max()
min()
input()

# Functions

def my_funct():
  pass

my_funct()

# Code Cleaning

def is_even(num):
  if num % 2 == 0:
    return True
  else:
    return False

"""# * args and ** kwargs"""

def get_specific_sum(*args, **kwargs):
  total = 0
  for items in kwargs.values():
    total += items
  return sum(args) + total

print(get_specific_sum(1,2,3,4,5, num1 = 5, num2 = 10))

# OBS: Best practice: params, *args, default params, **kwargs



"""# Let's exercise"""

import pandas as pd

def download_uci_dataset(url: str, column_names: list[str]) -> pd.DataFrame:

    df = pd.read_csv(url, header=None, names=column_names)
    return df

url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"
column_names = ["sepal_length", "sepal_width", "petal_length", "petal_width", "class"]
df = download_uci_dataset(url, column_names)

df

sepal_length_data = df['sepal_length'].tolist()

# sepal_length_data

# @title do not click yet
from typing import List

def apply_threshold(data: List[float], threshold: float) -> List[float]:
    """
    Apply a threshold to a list of numbers.

    Args:
        data (List[float]): The original list of numbers.
        threshold (float): The threshold value.

    Returns:
        List[float]: A new list where numbers below the threshold are set to 0.
    """
    return [x if x > threshold else 0 for x in data]



# threshold_value = 5
# new_data = apply_threshold(sepal_length_data, threshold_value)
# new_data

df['class'].value_counts()

# @title do not even try to click
import csv
import requests
import logging
from tqdm import tqdm
from typing import List, Dict

logging.basicConfig(level=logging.INFO)

def filter_iris_data(url: str, eligible_classes: List[str], length_range: List[float], width_threshold: float) -> List[Dict[str, float]]:
    """
    Filter Iris dataset based on multiple criteria.

    Args:
        url (str): URL of the Iris dataset.
        eligible_classes (List[str]): List of eligible class labels.
        length_range (List[float]): List specifying the min and max sepal length.
        width_threshold (float): Minimum sepal width.

    Returns:
        List[Dict[str, float]]: Filtered list of dictionaries containing sepal lengths, sepal widths, and class labels.
    """
    logging.info("Fetching data from URL.")
    response = requests.get(url)
    lines = response.text.strip().split("\n")
    reader = csv.reader(lines)

    filtered_data = []

    logging.info("Starting data filtering.")
    for row in tqdm(reader, desc="Filtering data", unit="row"):
        sepal_length = float(row[0])
        sepal_width = float(row[1])
        class_label = row[4]

        if class_label in eligible_classes:
            if length_range[0] <= sepal_length <= length_range[1]:
                if sepal_width > width_threshold:
                    filtered_data.append({
                        'sepal_length': sepal_length,
                        'sepal_width': sepal_width,
                        'class_label': class_label
                    })

    logging.info(f"Filtering complete. {len(filtered_data)} records found.")
    return filtered_data

url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"
eligible_classes = ['Iris-setosa', 'Iris-versicolor']
length_range = [4.0, 7.0]
width_threshold = 2.5

filtered_data = filter_iris_data(url, eligible_classes, length_range, width_threshold)

from typing import List, Dict

def filter_iris_data(url: str, eligible_classes: List[str], length_range: List[float], width_threshold: float) -> List[Dict[str, float]]:
    pass

url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"
eligible_classes = ['Iris-setosa', 'Iris-versicolor']
length_range = [4.0, 7.0]
width_threshold = 2.5

filtered_data = filter_iris_data(url, eligible_classes, length_range, width_threshold)

"""# Problema 1"""

# Create a function that checks the data in a list of dictionaries for specific validation rules, like checking if certain columns are non-empty, if numbers are within a range, etc.

data = [
    {'name': 'Alice', 'age': 30, 'email': 'alice@example.com'},
    {'name': 'Bob', 'age': '', 'email': 'bob@example.com'},  # Bob are certificat de nastere, totu bine, doar au uitat astia sa puna varsta ;)
    {'name': '', 'age': 20, 'email': 'carol@example.com'},   # Numele e uitat intentionat ;)
    {'name': 'Dave', 'age': 200, 'email': 'dave@example.com'} # Dave e world record pt cel mai batran om
]

validation_rules = {
    'name': {'required': True, 'type': str},
    'age': {'required': True, 'type': int, 'min': 0, 'max': 120},
    'email': {'required': True, 'type': str}
}

def validate_data(data, validation_rules):
  pass
  return errors

"""# Problema 2"""

# Make a join - inner join mai precis - intre cele 2 tabele, - manual join

table1 = [
    {'id': 1, 'name': 'Alice'},
    {'id': 2, 'name': 'Bob'},
    {'id': 3, 'name': 'Charlie'}
]

table2 = [
    {'id': 1, 'occupation': 'Engineer'},
    {'id': 2, 'occupation': 'Doctor'}
]


#Expected output

[
    {'id': 1, 'name': 'Alice', 'occupation': 'Engineer'},
    {'id': 2, 'name': 'Bob', 'occupation': 'Doctor'}
]

def join_tables(table1, table2, key):
  pass
  return

key = 'id'
joined_data = join_tables(table1, table2, key)

"""# Problema 3"""

#Design a function named categorize_expenses that takes a pandas DataFrame containing expense records and categorizes each expense based on provided rules. The DataFrame has two columns:
#Description containing a description of the expense, and Amount containing the numerical value of the expense.

#Requirements:

#The function must accept three arguments: the DataFrame expenses_df, a dictionary category_rules, and a default category name default_category.
#The category_rules dictionary keys are category names, and the values are lists of strings. Each expense should be categorized based on whether any of the strings in the list appear in the Description column of expenses_df.
#If an expense's description does not contain any of the strings specified in category_rules, it should be categorized as default_category.
#The function should add a new column to expenses_df named Category that contains the determined category for each expense.
#The function should return the modified DataFrame with the new Category column.

import pandas as pd

data = {
    'Description': ['Coffee at Starbucks', 'Grocery shopping at Walmart', 'Flight to NYC', 'Uber ride', 'Netflix subscription'],
    'Amount': [5.75, 76.32, 225.00, 13.45, 15.99]
}
expenses_df = pd.DataFrame(data)

category_rules = {
    'Food & Drink': ['Coffee', 'Grocery', 'Restaurant'],
    'Travel': ['Flight', 'Uber', 'Hotel'],
    'Entertainment': ['Netflix', 'Spotify', 'Cinema']
}

categorized_df = categorize_expenses(expenses_df, category_rules, 'Miscellaneous')

def categorize_expenses(expenses_df: pd.DataFrame, category_rules: dict, default_category: str) -> pd.DataFrame:
  pass
  return expenses_df

# Expected output

#               Description  Amount       Category
# 0     Coffee at Starbucks    5.75   Food & Drink
# 1  Grocery shopping at...   76.32   Food & Drink
# 2           Flight to NYC  225.00         Travel
# 3               Uber ride   13.45         Travel
# 4     Netflix subscription   15.99  Entertainment

"""# Problema 4"""

# Construct a function named loan_eligibility_predictor that assesses bank customers' eligibility for a loan product based on their financial history and other relevant attributes.
# The function will use a set of predefined rules to determine if a customer is eligible or not.

# Requirements:

# The function should add a new column to customers_df named Eligible that contains True if the customer meets all the criteria and False otherwise.
# The eligibility is determined by checking if the customer's attributes fall within the ranges specified in loan_criteria.
# If any attribute is outside the range, the customer is not eligible.
# The function should return the modified DataFrame with the eligibility decision.

data = {
    'Customer ID': [1, 2, 3, 4],
    'Age': [25, 40, 22, 35],
    'Annual Income': [50000, 80000, 30000, 120000],
    'Employment Status': ['Employed', 'Employed', 'Student', 'Employed'],
    'Credit Score': [700, 650, 720, 640],
    'Debt-to-Income Ratio': [0.3, 0.5, 0.2, 0.4]
}
customers_df = pd.DataFrame(data)


loan_criteria = {
    'Age': (18, 65),
    'Annual Income': (30000, 150000),
    'Credit Score': (680, 850),
    'Debt-to-Income Ratio': (0, 0.4)
}

# Expected output:
#    Customer ID  Age  Annual Income Employment Status  Credit Score  Debt-to-Income Ratio  Eligible
# 0            1   25          50000         Employed           700                    0.3      True
# 1            2   40          80000         Employed           650                    0.5     False
# 2            3   22          30000           Student          720                    0.2      True
# 3            4   35         120000         Employed           640                    0.4     False

def loan_eligibility_predictor(customers_df: pd.DataFrame, loan_criteria: dict) -> pd.DataFrame:
  pass
  return customers_df

result_df = loan_eligibility_predictor(customers_df, loan_criteria)
print(result_df)

"""# Problema 5"""

# Develop a function named detect_fraudulent_activity that scrutinizes bank transactions to identify potential fraudulent activity.
# The function will analyze a dataset of transactions, each with a date, amount, and a description, and flag those that meet certain criteria indicative of fraud.

# Requirements:

# The function should apply each fraud detection rule to each transaction.
# If a transaction is flagged by any of the rules, a new column Fraudulent should be set to True for that transaction; otherwise, it should be False.
# The function should also create a new column Flagged By that lists the names of the rules that flagged the transaction as potentially fraudulent.
# The function should return the modified DataFrame with the Fraudulent and Flagged By columns.

data = {
    'Date': ['2023-01-01', '2023-01-02', '2023-01-02', '2023-01-03'],
    'Amount': [100, 20000, 50, 5000],
    'Description': ['Payment', 'Withdrawal', 'Payment', 'Withdrawal']
}
transactions_df = pd.DataFrame(data)


def large_withdrawal(transaction):
    return transaction['Description'] == 'Withdrawal' and transaction['Amount'] > 10000

def even_amount(transaction):
    return transaction['Amount'] % 2 == 0

rules = {
    'Large Withdrawal': large_withdrawal,
    'Even Amount': even_amount
}

def detect_fraudulent_activity(transactions_df: pd.DataFrame, rules: dict) -> pd.DataFrame:
  pass
  return transactions_df

fraudulent_df = detect_fraudulent_activity(transactions_df, rules)
print(fraudulent_df)

# Expected output:

#          Date  Amount  Description  Fraudulent       Flagged By
# 0  2023-01-01     100      Payment       False               []
# 1  2023-01-02   20000   Withdrawal        True  [Large Withdrawal, Even Amount]
# 2  2023-01-02      50      Payment       False               []
# 3  2023-01-03    5000   Withdrawal        True       [Even Amount]

"""# Problema 6"""

# Design a function called account_summary that creates a financial summary for bank clients based on their account transactions over a period of time.
# The function should categorize transactions into Income, Expenses, and Transfers, and calculate totals for each category as well as the net flow of money.

# Requirements:

# The function should create a summary table with each category and its total amount.
# The function should also calculate the net flow (total income minus total expenses).
# Transactions not matching any category in categories should be classified as Uncategorized.
# The function should return a new DataFrame with the summary table.

data = {
    'Date': ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04'],
    'Amount': [1500, -100, 200, -500],
    'Transaction Type': ['Deposit', 'Withdrawal', 'Deposit', 'Withdrawal'],
    'Description': ['Salary', 'Grocery', 'Freelance Project', 'Rent']
}
transactions_df = pd.DataFrame(data)


categories = {
    'Income': ['Salary', 'Freelance'],
    'Expenses': ['Grocery', 'Rent'],
    'Transfers': ['Transfer']
}

def account_summary(transactions_df: pd.DataFrame, categories: dict) -> pd.DataFrame:
  pass
  return summary_df

summary_df = account_summary(transactions_df, categories)
print(summary_df)

# Expected output
#         Category  Total Amount
# 0        Income          1700
# 1      Expenses          -600
# 2     Transfers             0
# 3  Uncategorized            0
# 4     Net Flow           1100



"""# Problema 7"""

# Write a function named interest_rate_adjuster that simulates the adjustment of interest rates for a bank's savings accounts based on the total balance across all accounts.
# The bank adjusts the interest rates quarterly based on the total deposited amount: higher total balances lead to higher interest rates to attract more customers.

# Requirements:

# The function should calculate the total balance across all accounts.
# Based on the total balance, it should find the correct interest rate from rate_tiers.
# The function should then update a new column Interest Rate in accounts_df with the found rate.
# The function should return the modified DataFrame with updated interest rates.

data = {
    'Account ID': [1, 2, 3, 4],
    'Balance': [1000, 1500, 2000, 2500]
}
accounts_df = pd.DataFrame(data)


rate_tiers = [
    (5000, 0.01),  # 1% interest for total balance over $5000
    (10000, 0.015), # 1.5% interest for total balance over $10000
    (15000, 0.02)  # 2% interest for total balance over $15000
]

def interest_rate_adjuster(accounts_df: pd.DataFrame, rate_tiers: list) -> pd.DataFrame:
  pass
  return accounts_df

adjusted_accounts_df = interest_rate_adjuster(accounts_df, rate_tiers)
print(adjusted_accounts_df)

# Expected output

#    Account ID  Balance  Interest Rate
# 0           1     1000          0.01
# 1           2     1500          0.01
# 2           3     2000          0.01
# 3           4     2500          0.01